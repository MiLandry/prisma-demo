// Code generated by Prisma (prisma@1.25.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  courtCase: (where?: CourtCaseWhereInput) => Promise<boolean>;
  defendant: (where?: DefendantWhereInput) => Promise<boolean>;
  lawyer: (where?: LawyerWhereInput) => Promise<boolean>;
  person: (where?: PersonWhereInput) => Promise<boolean>;
  plaintiff: (where?: PlaintiffWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  courtCase: (where: CourtCaseWhereUniqueInput) => CourtCasePromise;
  courtCases: (args?: {
    where?: CourtCaseWhereInput;
    orderBy?: CourtCaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CourtCase>;
  courtCasesConnection: (args?: {
    where?: CourtCaseWhereInput;
    orderBy?: CourtCaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CourtCaseConnectionPromise;
  defendant: (where: DefendantWhereUniqueInput) => DefendantPromise;
  defendants: (args?: {
    where?: DefendantWhereInput;
    orderBy?: DefendantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Defendant>;
  defendantsConnection: (args?: {
    where?: DefendantWhereInput;
    orderBy?: DefendantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DefendantConnectionPromise;
  lawyer: (where: LawyerWhereUniqueInput) => LawyerPromise;
  lawyers: (args?: {
    where?: LawyerWhereInput;
    orderBy?: LawyerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Lawyer>;
  lawyersConnection: (args?: {
    where?: LawyerWhereInput;
    orderBy?: LawyerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LawyerConnectionPromise;
  person: (where: PersonWhereUniqueInput) => PersonPromise;
  persons: (args?: {
    where?: PersonWhereInput;
    orderBy?: PersonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Person>;
  personsConnection: (args?: {
    where?: PersonWhereInput;
    orderBy?: PersonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PersonConnectionPromise;
  plaintiff: (where: PlaintiffWhereUniqueInput) => PlaintiffPromise;
  plaintiffs: (args?: {
    where?: PlaintiffWhereInput;
    orderBy?: PlaintiffOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Plaintiff>;
  plaintiffsConnection: (args?: {
    where?: PlaintiffWhereInput;
    orderBy?: PlaintiffOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PlaintiffConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCourtCase: (data: CourtCaseCreateInput) => CourtCasePromise;
  updateCourtCase: (args: {
    data: CourtCaseUpdateInput;
    where: CourtCaseWhereUniqueInput;
  }) => CourtCasePromise;
  upsertCourtCase: (args: {
    where: CourtCaseWhereUniqueInput;
    create: CourtCaseCreateInput;
    update: CourtCaseUpdateInput;
  }) => CourtCasePromise;
  deleteCourtCase: (where: CourtCaseWhereUniqueInput) => CourtCasePromise;
  deleteManyCourtCases: (where?: CourtCaseWhereInput) => BatchPayloadPromise;
  createDefendant: (data: DefendantCreateInput) => DefendantPromise;
  updateDefendant: (args: {
    data: DefendantUpdateInput;
    where: DefendantWhereUniqueInput;
  }) => DefendantPromise;
  upsertDefendant: (args: {
    where: DefendantWhereUniqueInput;
    create: DefendantCreateInput;
    update: DefendantUpdateInput;
  }) => DefendantPromise;
  deleteDefendant: (where: DefendantWhereUniqueInput) => DefendantPromise;
  deleteManyDefendants: (where?: DefendantWhereInput) => BatchPayloadPromise;
  createLawyer: (data: LawyerCreateInput) => LawyerPromise;
  updateLawyer: (args: {
    data: LawyerUpdateInput;
    where: LawyerWhereUniqueInput;
  }) => LawyerPromise;
  upsertLawyer: (args: {
    where: LawyerWhereUniqueInput;
    create: LawyerCreateInput;
    update: LawyerUpdateInput;
  }) => LawyerPromise;
  deleteLawyer: (where: LawyerWhereUniqueInput) => LawyerPromise;
  deleteManyLawyers: (where?: LawyerWhereInput) => BatchPayloadPromise;
  createPerson: (data: PersonCreateInput) => PersonPromise;
  updatePerson: (args: {
    data: PersonUpdateInput;
    where: PersonWhereUniqueInput;
  }) => PersonPromise;
  updateManyPersons: (args: {
    data: PersonUpdateManyMutationInput;
    where?: PersonWhereInput;
  }) => BatchPayloadPromise;
  upsertPerson: (args: {
    where: PersonWhereUniqueInput;
    create: PersonCreateInput;
    update: PersonUpdateInput;
  }) => PersonPromise;
  deletePerson: (where: PersonWhereUniqueInput) => PersonPromise;
  deleteManyPersons: (where?: PersonWhereInput) => BatchPayloadPromise;
  createPlaintiff: (data: PlaintiffCreateInput) => PlaintiffPromise;
  updatePlaintiff: (args: {
    data: PlaintiffUpdateInput;
    where: PlaintiffWhereUniqueInput;
  }) => PlaintiffPromise;
  upsertPlaintiff: (args: {
    where: PlaintiffWhereUniqueInput;
    create: PlaintiffCreateInput;
    update: PlaintiffUpdateInput;
  }) => PlaintiffPromise;
  deletePlaintiff: (where: PlaintiffWhereUniqueInput) => PlaintiffPromise;
  deleteManyPlaintiffs: (where?: PlaintiffWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  courtCase: (
    where?: CourtCaseSubscriptionWhereInput
  ) => CourtCaseSubscriptionPayloadSubscription;
  defendant: (
    where?: DefendantSubscriptionWhereInput
  ) => DefendantSubscriptionPayloadSubscription;
  lawyer: (
    where?: LawyerSubscriptionWhereInput
  ) => LawyerSubscriptionPayloadSubscription;
  person: (
    where?: PersonSubscriptionWhereInput
  ) => PersonSubscriptionPayloadSubscription;
  plaintiff: (
    where?: PlaintiffSubscriptionWhereInput
  ) => PlaintiffSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type CourtCaseOrderByInput = "id_ASC" | "id_DESC";

export type DefendantOrderByInput = "id_ASC" | "id_DESC";

export type LawyerOrderByInput = "id_ASC" | "id_DESC";

export type PersonOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC";

export type PlaintiffOrderByInput = "id_ASC" | "id_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CourtCaseWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CourtCaseWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: CourtCaseWhereInput[] | CourtCaseWhereInput;
  OR?: CourtCaseWhereInput[] | CourtCaseWhereInput;
  NOT?: CourtCaseWhereInput[] | CourtCaseWhereInput;
}

export type DefendantWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface DefendantWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: DefendantWhereInput[] | DefendantWhereInput;
  OR?: DefendantWhereInput[] | DefendantWhereInput;
  NOT?: DefendantWhereInput[] | DefendantWhereInput;
}

export type LawyerWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface LawyerWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: LawyerWhereInput[] | LawyerWhereInput;
  OR?: LawyerWhereInput[] | LawyerWhereInput;
  NOT?: LawyerWhereInput[] | LawyerWhereInput;
}

export type PersonWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PersonWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  AND?: PersonWhereInput[] | PersonWhereInput;
  OR?: PersonWhereInput[] | PersonWhereInput;
  NOT?: PersonWhereInput[] | PersonWhereInput;
}

export type PlaintiffWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PlaintiffWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: PlaintiffWhereInput[] | PlaintiffWhereInput;
  OR?: PlaintiffWhereInput[] | PlaintiffWhereInput;
  NOT?: PlaintiffWhereInput[] | PlaintiffWhereInput;
}

export interface CourtCaseCreateInput {
  plaintiff: PlaintiffCreateOneInput;
  defendant: DefendantCreateOneInput;
  lawyer: LawyerCreateOneInput;
}

export interface PlaintiffCreateOneInput {
  create?: PlaintiffCreateInput;
  connect?: PlaintiffWhereUniqueInput;
}

export interface PlaintiffCreateInput {
  person?: PersonCreateOneInput;
}

export interface PersonCreateOneInput {
  create?: PersonCreateInput;
  connect?: PersonWhereUniqueInput;
}

export interface PersonCreateInput {
  firstName?: String;
  lastName?: String;
}

export interface DefendantCreateOneInput {
  create?: DefendantCreateInput;
  connect?: DefendantWhereUniqueInput;
}

export interface DefendantCreateInput {
  person?: PersonCreateOneInput;
}

export interface LawyerCreateOneInput {
  create?: LawyerCreateInput;
  connect?: LawyerWhereUniqueInput;
}

export interface LawyerCreateInput {
  person?: PersonCreateOneInput;
}

export interface CourtCaseUpdateInput {
  plaintiff?: PlaintiffUpdateOneRequiredInput;
  defendant?: DefendantUpdateOneRequiredInput;
  lawyer?: LawyerUpdateOneRequiredInput;
}

export interface PlaintiffUpdateOneRequiredInput {
  create?: PlaintiffCreateInput;
  update?: PlaintiffUpdateDataInput;
  upsert?: PlaintiffUpsertNestedInput;
  connect?: PlaintiffWhereUniqueInput;
}

export interface PlaintiffUpdateDataInput {
  person?: PersonUpdateOneInput;
}

export interface PersonUpdateOneInput {
  create?: PersonCreateInput;
  update?: PersonUpdateDataInput;
  upsert?: PersonUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PersonWhereUniqueInput;
}

export interface PersonUpdateDataInput {
  firstName?: String;
  lastName?: String;
}

export interface PersonUpsertNestedInput {
  update: PersonUpdateDataInput;
  create: PersonCreateInput;
}

export interface PlaintiffUpsertNestedInput {
  update: PlaintiffUpdateDataInput;
  create: PlaintiffCreateInput;
}

export interface DefendantUpdateOneRequiredInput {
  create?: DefendantCreateInput;
  update?: DefendantUpdateDataInput;
  upsert?: DefendantUpsertNestedInput;
  connect?: DefendantWhereUniqueInput;
}

export interface DefendantUpdateDataInput {
  person?: PersonUpdateOneInput;
}

export interface DefendantUpsertNestedInput {
  update: DefendantUpdateDataInput;
  create: DefendantCreateInput;
}

export interface LawyerUpdateOneRequiredInput {
  create?: LawyerCreateInput;
  update?: LawyerUpdateDataInput;
  upsert?: LawyerUpsertNestedInput;
  connect?: LawyerWhereUniqueInput;
}

export interface LawyerUpdateDataInput {
  person?: PersonUpdateOneInput;
}

export interface LawyerUpsertNestedInput {
  update: LawyerUpdateDataInput;
  create: LawyerCreateInput;
}

export interface DefendantUpdateInput {
  person?: PersonUpdateOneInput;
}

export interface LawyerUpdateInput {
  person?: PersonUpdateOneInput;
}

export interface PersonUpdateInput {
  firstName?: String;
  lastName?: String;
}

export interface PersonUpdateManyMutationInput {
  firstName?: String;
  lastName?: String;
}

export interface PlaintiffUpdateInput {
  person?: PersonUpdateOneInput;
}

export interface CourtCaseSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CourtCaseWhereInput;
  AND?: CourtCaseSubscriptionWhereInput[] | CourtCaseSubscriptionWhereInput;
  OR?: CourtCaseSubscriptionWhereInput[] | CourtCaseSubscriptionWhereInput;
  NOT?: CourtCaseSubscriptionWhereInput[] | CourtCaseSubscriptionWhereInput;
}

export interface DefendantSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DefendantWhereInput;
  AND?: DefendantSubscriptionWhereInput[] | DefendantSubscriptionWhereInput;
  OR?: DefendantSubscriptionWhereInput[] | DefendantSubscriptionWhereInput;
  NOT?: DefendantSubscriptionWhereInput[] | DefendantSubscriptionWhereInput;
}

export interface LawyerSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LawyerWhereInput;
  AND?: LawyerSubscriptionWhereInput[] | LawyerSubscriptionWhereInput;
  OR?: LawyerSubscriptionWhereInput[] | LawyerSubscriptionWhereInput;
  NOT?: LawyerSubscriptionWhereInput[] | LawyerSubscriptionWhereInput;
}

export interface PersonSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PersonWhereInput;
  AND?: PersonSubscriptionWhereInput[] | PersonSubscriptionWhereInput;
  OR?: PersonSubscriptionWhereInput[] | PersonSubscriptionWhereInput;
  NOT?: PersonSubscriptionWhereInput[] | PersonSubscriptionWhereInput;
}

export interface PlaintiffSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PlaintiffWhereInput;
  AND?: PlaintiffSubscriptionWhereInput[] | PlaintiffSubscriptionWhereInput;
  OR?: PlaintiffSubscriptionWhereInput[] | PlaintiffSubscriptionWhereInput;
  NOT?: PlaintiffSubscriptionWhereInput[] | PlaintiffSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface CourtCase {
  id: ID_Output;
}

export interface CourtCasePromise extends Promise<CourtCase>, Fragmentable {
  id: () => Promise<ID_Output>;
  plaintiff: <T = PlaintiffPromise>() => T;
  defendant: <T = DefendantPromise>() => T;
  lawyer: <T = LawyerPromise>() => T;
}

export interface CourtCaseSubscription
  extends Promise<AsyncIterator<CourtCase>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  plaintiff: <T = PlaintiffSubscription>() => T;
  defendant: <T = DefendantSubscription>() => T;
  lawyer: <T = LawyerSubscription>() => T;
}

export interface Plaintiff {
  id: ID_Output;
}

export interface PlaintiffPromise extends Promise<Plaintiff>, Fragmentable {
  id: () => Promise<ID_Output>;
  person: <T = PersonPromise>() => T;
}

export interface PlaintiffSubscription
  extends Promise<AsyncIterator<Plaintiff>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  person: <T = PersonSubscription>() => T;
}

export interface Person {
  id: ID_Output;
  firstName?: String;
  lastName?: String;
}

export interface PersonPromise extends Promise<Person>, Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
}

export interface PersonSubscription
  extends Promise<AsyncIterator<Person>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
}

export interface Defendant {
  id: ID_Output;
}

export interface DefendantPromise extends Promise<Defendant>, Fragmentable {
  id: () => Promise<ID_Output>;
  person: <T = PersonPromise>() => T;
}

export interface DefendantSubscription
  extends Promise<AsyncIterator<Defendant>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  person: <T = PersonSubscription>() => T;
}

export interface Lawyer {
  id: ID_Output;
}

export interface LawyerPromise extends Promise<Lawyer>, Fragmentable {
  id: () => Promise<ID_Output>;
  person: <T = PersonPromise>() => T;
}

export interface LawyerSubscription
  extends Promise<AsyncIterator<Lawyer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  person: <T = PersonSubscription>() => T;
}

export interface CourtCaseConnection {
  pageInfo: PageInfo;
  edges: CourtCaseEdge[];
}

export interface CourtCaseConnectionPromise
  extends Promise<CourtCaseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CourtCaseEdge>>() => T;
  aggregate: <T = AggregateCourtCasePromise>() => T;
}

export interface CourtCaseConnectionSubscription
  extends Promise<AsyncIterator<CourtCaseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CourtCaseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCourtCaseSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CourtCaseEdge {
  node: CourtCase;
  cursor: String;
}

export interface CourtCaseEdgePromise
  extends Promise<CourtCaseEdge>,
    Fragmentable {
  node: <T = CourtCasePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CourtCaseEdgeSubscription
  extends Promise<AsyncIterator<CourtCaseEdge>>,
    Fragmentable {
  node: <T = CourtCaseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCourtCase {
  count: Int;
}

export interface AggregateCourtCasePromise
  extends Promise<AggregateCourtCase>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCourtCaseSubscription
  extends Promise<AsyncIterator<AggregateCourtCase>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DefendantConnection {
  pageInfo: PageInfo;
  edges: DefendantEdge[];
}

export interface DefendantConnectionPromise
  extends Promise<DefendantConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DefendantEdge>>() => T;
  aggregate: <T = AggregateDefendantPromise>() => T;
}

export interface DefendantConnectionSubscription
  extends Promise<AsyncIterator<DefendantConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DefendantEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDefendantSubscription>() => T;
}

export interface DefendantEdge {
  node: Defendant;
  cursor: String;
}

export interface DefendantEdgePromise
  extends Promise<DefendantEdge>,
    Fragmentable {
  node: <T = DefendantPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DefendantEdgeSubscription
  extends Promise<AsyncIterator<DefendantEdge>>,
    Fragmentable {
  node: <T = DefendantSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDefendant {
  count: Int;
}

export interface AggregateDefendantPromise
  extends Promise<AggregateDefendant>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDefendantSubscription
  extends Promise<AsyncIterator<AggregateDefendant>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LawyerConnection {
  pageInfo: PageInfo;
  edges: LawyerEdge[];
}

export interface LawyerConnectionPromise
  extends Promise<LawyerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LawyerEdge>>() => T;
  aggregate: <T = AggregateLawyerPromise>() => T;
}

export interface LawyerConnectionSubscription
  extends Promise<AsyncIterator<LawyerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LawyerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLawyerSubscription>() => T;
}

export interface LawyerEdge {
  node: Lawyer;
  cursor: String;
}

export interface LawyerEdgePromise extends Promise<LawyerEdge>, Fragmentable {
  node: <T = LawyerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LawyerEdgeSubscription
  extends Promise<AsyncIterator<LawyerEdge>>,
    Fragmentable {
  node: <T = LawyerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLawyer {
  count: Int;
}

export interface AggregateLawyerPromise
  extends Promise<AggregateLawyer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLawyerSubscription
  extends Promise<AsyncIterator<AggregateLawyer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PersonConnection {
  pageInfo: PageInfo;
  edges: PersonEdge[];
}

export interface PersonConnectionPromise
  extends Promise<PersonConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PersonEdge>>() => T;
  aggregate: <T = AggregatePersonPromise>() => T;
}

export interface PersonConnectionSubscription
  extends Promise<AsyncIterator<PersonConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PersonEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePersonSubscription>() => T;
}

export interface PersonEdge {
  node: Person;
  cursor: String;
}

export interface PersonEdgePromise extends Promise<PersonEdge>, Fragmentable {
  node: <T = PersonPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PersonEdgeSubscription
  extends Promise<AsyncIterator<PersonEdge>>,
    Fragmentable {
  node: <T = PersonSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePerson {
  count: Int;
}

export interface AggregatePersonPromise
  extends Promise<AggregatePerson>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePersonSubscription
  extends Promise<AsyncIterator<AggregatePerson>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PlaintiffConnection {
  pageInfo: PageInfo;
  edges: PlaintiffEdge[];
}

export interface PlaintiffConnectionPromise
  extends Promise<PlaintiffConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlaintiffEdge>>() => T;
  aggregate: <T = AggregatePlaintiffPromise>() => T;
}

export interface PlaintiffConnectionSubscription
  extends Promise<AsyncIterator<PlaintiffConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlaintiffEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlaintiffSubscription>() => T;
}

export interface PlaintiffEdge {
  node: Plaintiff;
  cursor: String;
}

export interface PlaintiffEdgePromise
  extends Promise<PlaintiffEdge>,
    Fragmentable {
  node: <T = PlaintiffPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlaintiffEdgeSubscription
  extends Promise<AsyncIterator<PlaintiffEdge>>,
    Fragmentable {
  node: <T = PlaintiffSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePlaintiff {
  count: Int;
}

export interface AggregatePlaintiffPromise
  extends Promise<AggregatePlaintiff>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlaintiffSubscription
  extends Promise<AsyncIterator<AggregatePlaintiff>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CourtCaseSubscriptionPayload {
  mutation: MutationType;
  node: CourtCase;
  updatedFields: String[];
  previousValues: CourtCasePreviousValues;
}

export interface CourtCaseSubscriptionPayloadPromise
  extends Promise<CourtCaseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CourtCasePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CourtCasePreviousValuesPromise>() => T;
}

export interface CourtCaseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CourtCaseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CourtCaseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CourtCasePreviousValuesSubscription>() => T;
}

export interface CourtCasePreviousValues {
  id: ID_Output;
}

export interface CourtCasePreviousValuesPromise
  extends Promise<CourtCasePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface CourtCasePreviousValuesSubscription
  extends Promise<AsyncIterator<CourtCasePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface DefendantSubscriptionPayload {
  mutation: MutationType;
  node: Defendant;
  updatedFields: String[];
  previousValues: DefendantPreviousValues;
}

export interface DefendantSubscriptionPayloadPromise
  extends Promise<DefendantSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DefendantPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DefendantPreviousValuesPromise>() => T;
}

export interface DefendantSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DefendantSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DefendantSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DefendantPreviousValuesSubscription>() => T;
}

export interface DefendantPreviousValues {
  id: ID_Output;
}

export interface DefendantPreviousValuesPromise
  extends Promise<DefendantPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface DefendantPreviousValuesSubscription
  extends Promise<AsyncIterator<DefendantPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface LawyerSubscriptionPayload {
  mutation: MutationType;
  node: Lawyer;
  updatedFields: String[];
  previousValues: LawyerPreviousValues;
}

export interface LawyerSubscriptionPayloadPromise
  extends Promise<LawyerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LawyerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LawyerPreviousValuesPromise>() => T;
}

export interface LawyerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LawyerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LawyerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LawyerPreviousValuesSubscription>() => T;
}

export interface LawyerPreviousValues {
  id: ID_Output;
}

export interface LawyerPreviousValuesPromise
  extends Promise<LawyerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface LawyerPreviousValuesSubscription
  extends Promise<AsyncIterator<LawyerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface PersonSubscriptionPayload {
  mutation: MutationType;
  node: Person;
  updatedFields: String[];
  previousValues: PersonPreviousValues;
}

export interface PersonSubscriptionPayloadPromise
  extends Promise<PersonSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PersonPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PersonPreviousValuesPromise>() => T;
}

export interface PersonSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PersonSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PersonSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PersonPreviousValuesSubscription>() => T;
}

export interface PersonPreviousValues {
  id: ID_Output;
  firstName?: String;
  lastName?: String;
}

export interface PersonPreviousValuesPromise
  extends Promise<PersonPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
}

export interface PersonPreviousValuesSubscription
  extends Promise<AsyncIterator<PersonPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
}

export interface PlaintiffSubscriptionPayload {
  mutation: MutationType;
  node: Plaintiff;
  updatedFields: String[];
  previousValues: PlaintiffPreviousValues;
}

export interface PlaintiffSubscriptionPayloadPromise
  extends Promise<PlaintiffSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlaintiffPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlaintiffPreviousValuesPromise>() => T;
}

export interface PlaintiffSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlaintiffSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlaintiffSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlaintiffPreviousValuesSubscription>() => T;
}

export interface PlaintiffPreviousValues {
  id: ID_Output;
}

export interface PlaintiffPreviousValuesPromise
  extends Promise<PlaintiffPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface PlaintiffPreviousValuesSubscription
  extends Promise<AsyncIterator<PlaintiffPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "CourtCase",
    embedded: false
  },
  {
    name: "Defendant",
    embedded: false
  },
  {
    name: "Lawyer",
    embedded: false
  },
  {
    name: "Person",
    embedded: false
  },
  {
    name: "Plaintiff",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
